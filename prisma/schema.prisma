// Prisma Schema for Guru Builder System
// Database: PostgreSQL

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "darwin-arm64"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// USER MODEL (for Supabase Auth)
// ============================================================================

model User {
  id        String   @id // UUID from Supabase auth.users.id
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  projects              Project[]
  assessmentDefinitions AssessmentDefinition[]

  @@index([email])
}

// ============================================================================
// EXISTING MODELS (from backgammon-guru foundation)
// ============================================================================

model Project {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // User ownership
  userId      String?  // Nullable for migration period
  user        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Relations
  contextLayers      ContextLayer[]
  knowledgeFiles     KnowledgeFile[]
  researchRuns       ResearchRun[]
  snapshots          CorpusSnapshot[]
  assessmentConfig   SelfAssessmentConfig?  // DEPRECATED: kept for migration
  projectAssessments ProjectAssessment[]
  guruArtifacts      GuruArtifact[]
  promptConfigs      ProjectPromptConfig[]

  @@index([createdAt])
  @@index([userId])
}

model ContextLayer {
  id          String   @id @default(cuid())
  projectId   String
  title       String
  content     String   @db.Text
  priority    Int      // Lower number = higher priority (loaded first)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  project         Project          @relation(fields: [projectId], references: [id], onDelete: Cascade)
  recommendations Recommendation[] @relation("RecommendationToLayer")

  @@index([projectId, priority])
  @@index([projectId, isActive])
}

// ============================================================================
// NEW MODELS (Guru Builder extensions)
// ============================================================================

model KnowledgeFile {
  id          String   @id @default(cuid())
  projectId   String
  title       String
  description String?
  content     String   @db.Text
  category    String? // Optional categorization (e.g., "openings", "strategy")
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  project         Project          @relation(fields: [projectId], references: [id], onDelete: Cascade)
  recommendations Recommendation[] @relation("RecommendationToFile")

  @@index([projectId, isActive])
  @@index([projectId, category])
}

model ResearchRun {
  id             String         @id @default(cuid())
  projectId      String
  instructions   String         @db.Text // Research query/instructions
  depth          ResearchDepth  @default(MODERATE) // quick, moderate, deep
  status         ResearchStatus @default(PENDING)
  progressStage  String?        // Current stage: "searching", "analyzing", "synthesizing", etc.

  // Research results
  researchData   Json? // Raw research findings from GPT Researcher
  errorMessage   String?        @db.Text

  // Metadata
  startedAt      DateTime?
  completedAt    DateTime?
  executionTime  Int? // milliseconds
  tokensUsed     Int?
  costEstimate   Float? // USD

  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  // Relations
  project         Project          @relation(fields: [projectId], references: [id], onDelete: Cascade)
  recommendations Recommendation[]

  @@index([projectId, status])
  @@index([projectId, createdAt])
}

model Recommendation {
  id               String               @id @default(cuid())
  researchRunId    String

  // Recommendation type and target
  action           RecommendationAction // ADD, EDIT, DELETE
  targetType       TargetType           // LAYER or KNOWLEDGE_FILE

  // Separate FK fields (only one populated at a time based on targetType)
  contextLayerId   String?
  knowledgeFileId  String?

  // Recommendation content
  title            String
  description      String               @db.Text // Brief summary of what's changing
  fullContent      String               @db.Text // Complete, production-ready content to apply
  reasoning        String               @db.Text // Why this recommendation matters

  // Metadata
  confidence       Float // 0.0 to 1.0
  impactLevel      ImpactLevel // LOW, MEDIUM, HIGH
  priority         Int // Ordering within research run

  // Approval workflow
  status           RecommendationStatus @default(PENDING) // PENDING, APPROVED, REJECTED, APPLIED
  reviewedAt       DateTime?
  appliedAt        DateTime?

  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt

  // Relations
  researchRun      ResearchRun          @relation(fields: [researchRunId], references: [id], onDelete: Cascade)
  contextLayer     ContextLayer?        @relation("RecommendationToLayer", fields: [contextLayerId], references: [id], onDelete: SetNull)
  knowledgeFile    KnowledgeFile?       @relation("RecommendationToFile", fields: [knowledgeFileId], references: [id], onDelete: SetNull)
  applyChangesLogs ApplyChangesLog[]

  @@index([researchRunId, status])
  @@index([researchRunId, priority])
  @@index([contextLayerId])
  @@index([knowledgeFileId])
}

model CorpusSnapshot {
  id          String   @id @default(cuid())
  projectId   String
  name        String // Auto-generated or user-provided
  description String?  @db.Text

  // Snapshot data
  layersData  Json // Snapshot of all ContextLayers
  filesData   Json // Snapshot of all KnowledgeFiles

  // Metadata
  createdAt   DateTime @default(now())
  restoredAt  DateTime?

  // Relations
  project           Project           @relation(fields: [projectId], references: [id], onDelete: Cascade)
  applyChangesLogs  ApplyChangesLog[]

  @@index([projectId, createdAt])
}

model ApplyChangesLog {
  id                   String   @id @default(cuid())
  snapshotId           String // Pre-apply snapshot
  recommendationId     String

  // What was changed
  changeType           RecommendationAction
  targetType           TargetType
  targetId             String? // ID of created/modified/deleted entity

  // Change details
  previousValue        Json? // For EDIT/DELETE
  newValue             Json? // For ADD/EDIT

  createdAt            DateTime @default(now())

  // Relations
  snapshot             CorpusSnapshot @relation(fields: [snapshotId], references: [id], onDelete: Cascade)
  recommendation       Recommendation @relation(fields: [recommendationId], references: [id], onDelete: Cascade)

  @@index([snapshotId])
  @@index([recommendationId])
}

// ============================================================================
// SELF-ASSESSMENT MODELS (New Library Architecture)
// ============================================================================

// Reusable assessment definitions owned by users (the "library")
model AssessmentDefinition {
  id          String   @id @default(cuid())
  userId      String
  name        String
  description String?  @db.Text
  domain      String   // e.g., "backgammon", "chess", "poker"
  engineType  String?  // e.g., "gnubg", "stockfish", null for manual
  engineUrl   String?  // MCP server URL for engine integration
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user               User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  projectAssessments ProjectAssessment[]

  @@index([userId])
  @@index([domain])
}

// Junction table: links AssessmentDefinitions to Projects
model ProjectAssessment {
  id                     String   @id @default(cuid())
  projectId              String
  assessmentDefinitionId String
  isEnabled              Boolean  @default(true)
  createdAt              DateTime @default(now())

  project              Project              @relation(fields: [projectId], references: [id], onDelete: Cascade)
  assessmentDefinition AssessmentDefinition @relation(fields: [assessmentDefinitionId], references: [id], onDelete: Cascade)
  sessions             AssessmentSession[]

  @@unique([projectId, assessmentDefinitionId])
  @@index([projectId])
  @@index([assessmentDefinitionId])
}

// ============================================================================
// SELF-ASSESSMENT MODELS (Legacy - DEPRECATED, kept for migration)
// ============================================================================

model SelfAssessmentConfig {
  id        String   @id @default(cuid())
  projectId String   @unique

  engineUrl String  @default("https://gnubg-mcp-d1c3c7a814e8.herokuapp.com")
  isEnabled Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project  Project             @relation(fields: [projectId], references: [id], onDelete: Cascade)
  sessions AssessmentSession[]

  @@index([projectId])
}

model AssessmentSession {
  id       String @id @default(cuid())
  configId String?  // DEPRECATED: legacy reference, nullable for new sessions

  // New architecture reference
  projectAssessmentId String?

  startedAt    DateTime  @default(now())
  endedAt      DateTime?
  lastResultId String? // Track last result for "Continue Session" feature

  // Legacy relation (kept for migration)
  config            SelfAssessmentConfig? @relation(fields: [configId], references: [id], onDelete: Cascade)
  // New relation
  projectAssessment ProjectAssessment?    @relation(fields: [projectAssessmentId], references: [id], onDelete: Cascade)
  results           AssessmentResult[]

  @@index([configId])
  @@index([projectAssessmentId])
  @@index([startedAt])
}

model AssessmentResult {
  id        String @id @default(cuid())
  sessionId String

  diceRoll String
  position String @default("opening")

  guruResponse String @db.Text

  bestMoves Json

  guruMatchedBest Boolean?
  userRating      Int? // 1-5 user satisfaction rating

  createdAt DateTime @default(now())

  session AssessmentSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([createdAt])
}

// ============================================================================
// GURU TEACHING ARTIFACTS
// ============================================================================

// Generated teaching artifact (mental models, curricula, drill series)
model GuruArtifact {
  id          String           @id @default(cuid())
  projectId   String

  type        GuruArtifactType
  version     Int              @default(1)

  // Structured content (JSON)
  content     Json

  // Human-readable version (Markdown with ASCII wireframes for drills)
  markdownContent String?      @db.Text

  // Generation metadata
  corpusHash      String?      // Hash of corpus state when generated
  generatedAt     DateTime     @default(now())

  // Prompt versioning - tracks which prompts generated this artifact
  systemPromptHash    String?   // Hash of system prompt used
  userPromptHash      String?   // Hash of user prompt template used
  promptConfigId      String?   // Reference to ProjectPromptConfig if custom prompts used

  // For tracking dependencies
  dependsOnArtifactId String?  // ID of artifact this one builds on

  // Status tracking
  status      ArtifactStatus   @default(COMPLETED)

  // Error message if failed
  errorMessage String?         @db.Text

  // Progress tracking (for UI display during generation)
  progressStage String?        // Current phase key (e.g., "COMPOSING_CORPUS")

  // Relations
  project     Project          @relation(fields: [projectId], references: [id], onDelete: Cascade)
  dependsOn   GuruArtifact?    @relation("ArtifactDependency", fields: [dependsOnArtifactId], references: [id])
  dependents  GuruArtifact[]   @relation("ArtifactDependency")

  @@index([projectId, type])
  @@index([projectId, type, version])
  @@index([generatedAt])
}

// ============================================================================
// PER-PROJECT PROMPT CUSTOMIZATION
// ============================================================================

// Custom prompt configuration per project per artifact type
model ProjectPromptConfig {
  id          String   @id @default(cuid())
  projectId   String

  // Which artifact type this config applies to
  artifactType GuruArtifactType  // MENTAL_MODEL | CURRICULUM | DRILL_SERIES

  // Custom prompts (null means use default)
  customSystemPrompt String?  @db.Text
  customUserPrompt   String?  @db.Text

  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  history     PromptConfigHistory[]

  // Unique constraint: one config per project per artifact type
  @@unique([projectId, artifactType])
  @@index([projectId])
}

// Track history of prompt changes for analysis
model PromptConfigHistory {
  id              String   @id @default(cuid())
  configId        String

  // Snapshot of prompts at this point in time
  systemPrompt    String?  @db.Text
  userPrompt      String?  @db.Text

  // Change metadata
  changeType      PromptChangeType  // CREATED | UPDATED | RESET
  changedAt       DateTime @default(now())

  // Hash for quick comparison (matches GuruArtifact.systemPromptHash/userPromptHash)
  systemPromptHash String?
  userPromptHash   String?

  config          ProjectPromptConfig @relation(fields: [configId], references: [id], onDelete: Cascade)

  @@index([configId, changedAt])
}

// ============================================================================
// ENUMS
// ============================================================================

enum PromptChangeType {
  CREATED
  UPDATED
  RESET
}

enum GuruArtifactType {
  MENTAL_MODEL
  CURRICULUM
  DRILL_SERIES
}

enum ArtifactStatus {
  GENERATING
  COMPLETED
  FAILED
}

enum ResearchDepth {
  QUICK    // 1-2 minutes, 5 sources
  MODERATE // 3-5 minutes, 10 sources
  DEEP     // 5-10 minutes, 20 sources
}

enum ResearchStatus {
  PENDING    // Queued, not started
  RUNNING    // Currently executing
  COMPLETED  // Finished successfully
  FAILED     // Error occurred
  CANCELLED  // User cancelled
}

enum RecommendationAction {
  ADD    // Create new layer or file
  EDIT   // Modify existing
  DELETE // Remove existing
}

enum TargetType {
  LAYER          // ContextLayer
  KNOWLEDGE_FILE // KnowledgeFile
}

enum ImpactLevel {
  LOW    // Minor improvement
  MEDIUM // Moderate improvement
  HIGH   // Significant improvement
}

enum RecommendationStatus {
  PENDING  // Awaiting review
  APPROVED // Approved, ready to apply
  REJECTED // Rejected by user
  APPLIED  // Successfully applied
}
