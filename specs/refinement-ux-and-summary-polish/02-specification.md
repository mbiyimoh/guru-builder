# Specification: Refinement UX Enhancement & Research Summary Polish

**Version:** 1.0
**Created:** 2025-01-04
**Ideation:** specs/refinement-ux-and-summary-polish/01-ideation.md

---

## Overview

Two UX improvements to the research and recommendations workflow:

1. **Refinement UX Enhancement:** Auto-expand content preview when refining; show inline diff after refinement
2. **Research Summary Fix:** Generate proper standalone summary (not truncation); render with markdown

---

## Phase 1: Research Summary Fix

### Problem Statement

The current summary is generated by truncating the full report:
```typescript
// lib/researchOrchestrator.ts:195
const summary = fullReport.slice(0, 500) + "...";
```

This causes:
- Raw markdown symbols displayed (`#`, `##`, `-`, `**`)
- Content cuts mid-sentence
- No meaningful summary structure

### Solution

Generate a standalone summary via separate GPT call with enforced structure and character limit.

### Technical Design

#### 1.1 Update Research Orchestrator

**File:** `lib/researchOrchestrator.ts`

**Changes:**
1. Add `generateSummary()` function after full report generation
2. Call GPT with structured prompt for summary
3. Enforce max 500-600 characters in prompt

```typescript
/**
 * Generate a concise summary from the full research report
 */
async function generateSummary(fullReport: string, query: string): Promise<string> {
  const completion = await getOpenAI().chat.completions.create({
    model: RESEARCH_MODEL,
    messages: [
      {
        role: "system",
        content: `You are a research summarizer. Create a brief, scannable summary of research findings.

Format Requirements:
- Start with ONE introductory sentence (max 100 chars)
- Follow with 3-4 bullet points of key findings
- Each bullet should be 60-100 chars
- Total output MUST be under 500 characters
- Use plain text, NO markdown formatting (no #, **, etc.)
- Write for quick scanning, not deep reading`
      },
      {
        role: "user",
        content: `Summarize this research report about "${query}":\n\n${fullReport.slice(0, 3000)}`
      }
    ],
    temperature: 0.5,
    max_tokens: 300,
  });

  return completion.choices[0]?.message?.content?.trim() ||
    "Research completed. See full report for details.";
}
```

**Update `executeResearch()` function:**
```typescript
// After line 194 (where fullReport is set)
const fullReport = completion.choices[0]?.message?.content || "";

// Replace truncation with proper summary generation
const summary = await generateSummary(fullReport, instructions);
```

#### 1.2 Update Research Findings Display

**File:** `components/research/ResearchFindingsView.tsx`

**Changes:**
1. The `extractKeyTakeaways()` function already handles bullet extraction
2. Since summary will now be plain text with bullets, existing logic works
3. No changes needed if summary is properly formatted

**Validation:** The existing `extractKeyTakeaways()` function (lines 18-62) already:
- Looks for bullet points (`-`, `•`, `*`)
- Falls back to numbered lists
- Falls back to sentences

If the GPT summary uses `-` bullets, the extractor will work correctly.

#### 1.3 Update Full Report Modal (Optional Enhancement)

**File:** `components/research/FullReportModal.tsx`

**Changes:** Render full report with markdown for better formatting.

```typescript
import ReactMarkdown from 'react-markdown';

// Replace plain text rendering (line 76-79) with:
<div className="bg-gray-50 border border-gray-200 rounded-lg p-4 max-h-96 overflow-y-auto">
  <div className="prose prose-sm max-w-none">
    <ReactMarkdown>{fullReport}</ReactMarkdown>
  </div>
</div>
```

---

## Phase 2: Refinement UX Enhancement

### Problem Statement

1. Users click "Refine this recommendation" but can't see what they're refining
2. After refinement, no visual indication of what changed

### Solution

1. Auto-expand "View Full Proposed" when refinement panel opens
2. Show inline diff view after refinement completes (red strikethrough for removed, green for added)
3. Diff clears on next action (approve/reject/refresh)

### Technical Design

#### 2.1 Add State for Content Expansion and Diff

**File:** `app/projects/[id]/research/[runId]/RecommendationsView.tsx`

**New State:**
```typescript
// Track which recommendation has content auto-expanded for refinement
const [refinementExpandedId, setRefinementExpandedId] = useState<string | null>(null);

// Track pre-refinement content for diff display
const [preRefinementContent, setPreRefinementContent] = useState<{
  id: string;
  fullContent: string;
} | null>(null);
```

#### 2.2 Update RefinementInput Props

**File:** `components/recommendations/RefinementInput.tsx`

**Add callbacks:**
```typescript
interface RefinementInputProps {
  recommendationId: string;
  currentContent: string;  // NEW: Pass current content for tracking
  disabled?: boolean;
  onRefinementStart?: (content: string) => void;  // NEW: Called when refinement begins
  onRefinementComplete: () => void;
}
```

**Update handler:**
```typescript
const handleRefine = async () => {
  if (!prompt.trim() || isRefining || disabled) return;

  // Notify parent that refinement is starting (for diff tracking)
  onRefinementStart?.(/* current content passed via prop */);

  setIsRefining(true);
  // ... rest of existing logic
};
```

#### 2.3 Create Inline Content Diff Component

**File:** `components/recommendations/InlineContentDiff.tsx` (NEW)

```typescript
'use client';

import { diffLines, Change } from 'diff';

interface InlineContentDiffProps {
  originalContent: string;
  newContent: string;
}

interface DiffSegment {
  value: string;
  type: 'addition' | 'deletion' | 'unchanged';
}

function computeDiff(oldText: string, newText: string): DiffSegment[] {
  const changes: Change[] = diffLines(oldText, newText);
  return changes.map((change) => ({
    value: change.value,
    type: change.added ? 'addition' : change.removed ? 'deletion' : 'unchanged',
  }));
}

export function InlineContentDiff({ originalContent, newContent }: InlineContentDiffProps) {
  const segments = computeDiff(originalContent, newContent);

  return (
    <div className="p-4 bg-gray-50 rounded-md border border-gray-200 max-h-96 overflow-y-auto">
      <div className="text-xs text-gray-500 mb-2 flex items-center gap-4">
        <span className="flex items-center gap-1">
          <span className="w-3 h-3 bg-red-100 border border-red-300 rounded"></span>
          Removed
        </span>
        <span className="flex items-center gap-1">
          <span className="w-3 h-3 bg-green-100 border border-green-300 rounded"></span>
          Added
        </span>
      </div>
      <pre className="whitespace-pre-wrap text-sm font-mono">
        {segments.map((segment, index) => {
          if (segment.type === 'unchanged') {
            return <span key={index}>{segment.value}</span>;
          }
          if (segment.type === 'addition') {
            return (
              <span
                key={index}
                className="bg-green-100 text-green-800"
              >
                {segment.value}
              </span>
            );
          }
          if (segment.type === 'deletion') {
            return (
              <span
                key={index}
                className="bg-red-100 text-red-800 line-through"
              >
                {segment.value}
              </span>
            );
          }
          return null;
        })}
      </pre>
    </div>
  );
}
```

#### 2.4 Wire Up RecommendationsView

**File:** `app/projects/[id]/research/[runId]/RecommendationsView.tsx`

**Update recommendation card rendering:**

```typescript
{/* Full Content Preview - auto-open when refining */}
{rec.action === 'EDIT' && (rec.contextLayerId || rec.knowledgeFileId) ? (
  <details
    className="mb-3"
    open={refinementExpandedId === rec.id || expandedDiffs.has(rec.id)}
    onToggle={(e) => {
      // ... existing toggle logic
    }}
  >
    <summary>View Changes</summary>
    <div className="mt-3">
      {/* Show diff if we have pre-refinement content for this rec */}
      {preRefinementContent?.id === rec.id ? (
        <InlineContentDiff
          originalContent={preRefinementContent.fullContent}
          newContent={rec.fullContent}
        />
      ) : (
        <DiffViewer ... />
      )}
    </div>
  </details>
) : (
  <details
    className="mb-3"
    open={refinementExpandedId === rec.id}
  >
    <summary>View Full Content</summary>
    <div className="mt-3 p-4 bg-gray-50 rounded-md">
      {/* Show diff if we have pre-refinement content */}
      {preRefinementContent?.id === rec.id ? (
        <InlineContentDiff
          originalContent={preRefinementContent.fullContent}
          newContent={rec.fullContent}
        />
      ) : (
        <pre className="whitespace-pre-wrap text-sm">
          {rec.fullContent}
        </pre>
      )}
    </div>
  </details>
)}

{/* Refinement Input */}
{rec.status === 'PENDING' && (
  <div className="mb-4">
    <RefinementInput
      recommendationId={rec.id}
      currentContent={rec.fullContent}
      disabled={loadingId === rec.id}
      onRefinementStart={(content) => {
        setRefinementExpandedId(rec.id);
        setPreRefinementContent({ id: rec.id, fullContent: content });
      }}
      onRefinementComplete={() => {
        router.refresh();
        // Keep preRefinementContent to show diff after refresh
      }}
    />
  </div>
)}
```

**Clear diff on approve/reject:**
```typescript
const handleApprove = async (id: string) => {
  setLoadingId(id);
  setPreRefinementContent(null);  // Clear diff
  setRefinementExpandedId(null);
  // ... rest of existing logic
};

const handleReject = async (id: string) => {
  setLoadingId(id);
  setPreRefinementContent(null);  // Clear diff
  setRefinementExpandedId(null);
  // ... rest of existing logic
};
```

---

## API Changes

### No API Changes Required

- Phase 1: Changes are in the research orchestrator (backend logic), no new endpoints
- Phase 2: Uses existing `/api/recommendations/[id]/refine` endpoint

---

## Database Changes

### No Database Changes Required

- Summary field already exists in research data JSON
- No schema migrations needed

---

## Testing Strategy

### Phase 1: Research Summary
1. Run new research on a project
2. Verify summary displays as intro sentence + 3-4 bullets
3. Verify no raw markdown symbols visible
4. Verify full report modal renders markdown correctly

### Phase 2: Refinement UX
1. Click "Refine this recommendation" on a PENDING recommendation
2. Verify "View Full Proposed/Content" auto-expands
3. Enter refinement prompt and submit
4. Verify diff view shows (red strikethrough for removed, green for added)
5. Click Approve - verify diff clears
6. Repeat with Reject - verify diff clears

---

## Files to Modify

| File | Phase | Changes |
|------|-------|---------|
| `lib/researchOrchestrator.ts` | 1 | Add `generateSummary()`, replace truncation |
| `components/research/FullReportModal.tsx` | 1 | Add ReactMarkdown for full report |
| `components/recommendations/InlineContentDiff.tsx` | 2 | NEW: Inline diff component |
| `components/recommendations/RefinementInput.tsx` | 2 | Add `onRefinementStart` callback, `currentContent` prop |
| `app/projects/[id]/research/[runId]/RecommendationsView.tsx` | 2 | Add state, wire up auto-expand and diff |

---

## Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| Extra GPT call adds latency | Summary generation is fast (~1s); runs after main report |
| Summary exceeds char limit | Prompt enforces limit; fallback to truncation if needed |
| Diff view confusing for users | Clear legend (red=removed, green=added); ephemeral display |
| State complexity in RecommendationsView | Keep state minimal; clear on actions |

---

## Success Criteria

1. ✅ Research summaries display as formatted bullets (no raw markdown)
2. ✅ Summaries are coherent (not mid-sentence truncation)
3. ✅ Content auto-expands when clicking "Refine this recommendation"
4. ✅ Diff view shows after refinement with red strikethrough/green highlighting
5. ✅ Diff clears on approve/reject/refresh
